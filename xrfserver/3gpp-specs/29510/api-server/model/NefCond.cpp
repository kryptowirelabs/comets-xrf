/**
* NRF NFManagement Service
* NRF NFManagement Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
*
* The version of the OpenAPI document: 1.2.0-alpha.5
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "NefCond.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

NefCond::NefCond()
{
    m_ConditionType = "";
    m_AfEventsIsSet = false;
    m_SnssaiListIsSet = false;
    m_PfdDataIsSet = false;
    m_GpsiRangesIsSet = false;
    m_ExternalGroupIdentifiersRangesIsSet = false;
    m_ServedFqdnListIsSet = false;
    
}

void NefCond::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool NefCond::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool NefCond::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "NefCond" : pathPrefix;

             
    if (afEventsIsSet())
    {
        const std::vector<AfEvent>& value = m_AfEvents;
        const std::string currentValuePath = _pathPrefix + ".afEvents";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const AfEvent& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".afEvents") && success;
 
                i++;
            }
        }

    }
         
    if (snssaiListIsSet())
    {
        const std::vector<Snssai>& value = m_SnssaiList;
        const std::string currentValuePath = _pathPrefix + ".snssaiList";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const Snssai& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".snssaiList") && success;
 
                i++;
            }
        }

    }
             
    if (gpsiRangesIsSet())
    {
        const std::vector<IdentityRange>& value = m_GpsiRanges;
        const std::string currentValuePath = _pathPrefix + ".gpsiRanges";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const IdentityRange& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".gpsiRanges") && success;
 
                i++;
            }
        }

    }
         
    if (externalGroupIdentifiersRangesIsSet())
    {
        const std::vector<IdentityRange>& value = m_ExternalGroupIdentifiersRanges;
        const std::string currentValuePath = _pathPrefix + ".externalGroupIdentifiersRanges";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const IdentityRange& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".externalGroupIdentifiersRanges") && success;
 
                i++;
            }
        }

    }
         
    if (servedFqdnListIsSet())
    {
        const std::vector<std::string>& value = m_ServedFqdnList;
        const std::string currentValuePath = _pathPrefix + ".servedFqdnList";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
    
    return success;
}

bool NefCond::operator==(const NefCond& rhs) const
{
    return
    
    
    (getConditionType() == rhs.getConditionType())
     &&
    
    
    ((!afEventsIsSet() && !rhs.afEventsIsSet()) || (afEventsIsSet() && rhs.afEventsIsSet() && getAfEvents() == rhs.getAfEvents())) &&
    
    
    ((!snssaiListIsSet() && !rhs.snssaiListIsSet()) || (snssaiListIsSet() && rhs.snssaiListIsSet() && getSnssaiList() == rhs.getSnssaiList())) &&
    
    
    ((!pfdDataIsSet() && !rhs.pfdDataIsSet()) || (pfdDataIsSet() && rhs.pfdDataIsSet() && getPfdData() == rhs.getPfdData())) &&
    
    
    ((!gpsiRangesIsSet() && !rhs.gpsiRangesIsSet()) || (gpsiRangesIsSet() && rhs.gpsiRangesIsSet() && getGpsiRanges() == rhs.getGpsiRanges())) &&
    
    
    ((!externalGroupIdentifiersRangesIsSet() && !rhs.externalGroupIdentifiersRangesIsSet()) || (externalGroupIdentifiersRangesIsSet() && rhs.externalGroupIdentifiersRangesIsSet() && getExternalGroupIdentifiersRanges() == rhs.getExternalGroupIdentifiersRanges())) &&
    
    
    ((!servedFqdnListIsSet() && !rhs.servedFqdnListIsSet()) || (servedFqdnListIsSet() && rhs.servedFqdnListIsSet() && getServedFqdnList() == rhs.getServedFqdnList()))
    
    ;
}

bool NefCond::operator!=(const NefCond& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const NefCond& o)
{
    j = nlohmann::json();
    j["conditionType"] = o.m_ConditionType;
    if(o.afEventsIsSet() || !o.m_AfEvents.empty())
        j["afEvents"] = o.m_AfEvents;
    if(o.snssaiListIsSet() || !o.m_SnssaiList.empty())
        j["snssaiList"] = o.m_SnssaiList;
    if(o.pfdDataIsSet())
        j["pfdData"] = o.m_PfdData;
    if(o.gpsiRangesIsSet() || !o.m_GpsiRanges.empty())
        j["gpsiRanges"] = o.m_GpsiRanges;
    if(o.externalGroupIdentifiersRangesIsSet() || !o.m_ExternalGroupIdentifiersRanges.empty())
        j["externalGroupIdentifiersRanges"] = o.m_ExternalGroupIdentifiersRanges;
    if(o.servedFqdnListIsSet() || !o.m_ServedFqdnList.empty())
        j["servedFqdnList"] = o.m_ServedFqdnList;
    
}

void from_json(const nlohmann::json& j, NefCond& o)
{
    j.at("conditionType").get_to(o.m_ConditionType);
    if(j.find("afEvents") != j.end())
    {
        j.at("afEvents").get_to(o.m_AfEvents);
        o.m_AfEventsIsSet = true;
    } 
    if(j.find("snssaiList") != j.end())
    {
        j.at("snssaiList").get_to(o.m_SnssaiList);
        o.m_SnssaiListIsSet = true;
    } 
    if(j.find("pfdData") != j.end())
    {
        j.at("pfdData").get_to(o.m_PfdData);
        o.m_PfdDataIsSet = true;
    } 
    if(j.find("gpsiRanges") != j.end())
    {
        j.at("gpsiRanges").get_to(o.m_GpsiRanges);
        o.m_GpsiRangesIsSet = true;
    } 
    if(j.find("externalGroupIdentifiersRanges") != j.end())
    {
        j.at("externalGroupIdentifiersRanges").get_to(o.m_ExternalGroupIdentifiersRanges);
        o.m_ExternalGroupIdentifiersRangesIsSet = true;
    } 
    if(j.find("servedFqdnList") != j.end())
    {
        j.at("servedFqdnList").get_to(o.m_ServedFqdnList);
        o.m_ServedFqdnListIsSet = true;
    } 
    
}

std::string NefCond::getConditionType() const
{
    return m_ConditionType;
}
void NefCond::setConditionType(std::string const& value)
{
    m_ConditionType = value;
}
std::vector<AfEvent> NefCond::getAfEvents() const
{
    return m_AfEvents;
}
void NefCond::setAfEvents(std::vector<AfEvent> const& value)
{
    m_AfEvents = value;
    m_AfEventsIsSet = true;
}
bool NefCond::afEventsIsSet() const
{
    return m_AfEventsIsSet;
}
void NefCond::unsetAfEvents()
{
    m_AfEventsIsSet = false;
}
std::vector<Snssai> NefCond::getSnssaiList() const
{
    return m_SnssaiList;
}
void NefCond::setSnssaiList(std::vector<Snssai> const& value)
{
    m_SnssaiList = value;
    m_SnssaiListIsSet = true;
}
bool NefCond::snssaiListIsSet() const
{
    return m_SnssaiListIsSet;
}
void NefCond::unsetSnssaiList()
{
    m_SnssaiListIsSet = false;
}
PfdData NefCond::getPfdData() const
{
    return m_PfdData;
}
void NefCond::setPfdData(PfdData const& value)
{
    m_PfdData = value;
    m_PfdDataIsSet = true;
}
bool NefCond::pfdDataIsSet() const
{
    return m_PfdDataIsSet;
}
void NefCond::unsetPfdData()
{
    m_PfdDataIsSet = false;
}
std::vector<IdentityRange> NefCond::getGpsiRanges() const
{
    return m_GpsiRanges;
}
void NefCond::setGpsiRanges(std::vector<IdentityRange> const& value)
{
    m_GpsiRanges = value;
    m_GpsiRangesIsSet = true;
}
bool NefCond::gpsiRangesIsSet() const
{
    return m_GpsiRangesIsSet;
}
void NefCond::unsetGpsiRanges()
{
    m_GpsiRangesIsSet = false;
}
std::vector<IdentityRange> NefCond::getExternalGroupIdentifiersRanges() const
{
    return m_ExternalGroupIdentifiersRanges;
}
void NefCond::setExternalGroupIdentifiersRanges(std::vector<IdentityRange> const& value)
{
    m_ExternalGroupIdentifiersRanges = value;
    m_ExternalGroupIdentifiersRangesIsSet = true;
}
bool NefCond::externalGroupIdentifiersRangesIsSet() const
{
    return m_ExternalGroupIdentifiersRangesIsSet;
}
void NefCond::unsetExternalGroupIdentifiersRanges()
{
    m_ExternalGroupIdentifiersRangesIsSet = false;
}
std::vector<std::string> NefCond::getServedFqdnList() const
{
    return m_ServedFqdnList;
}
void NefCond::setServedFqdnList(std::vector<std::string> const& value)
{
    m_ServedFqdnList = value;
    m_ServedFqdnListIsSet = true;
}
bool NefCond::servedFqdnListIsSet() const
{
    return m_ServedFqdnListIsSet;
}
void NefCond::unsetServedFqdnList()
{
    m_ServedFqdnListIsSet = false;
}


} // namespace org::openapitools::server::model

