/**
* NRF NFManagement Service
* NRF NFManagement Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
*
* The version of the OpenAPI document: 1.2.0-alpha.5
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "PcscfInfo.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

PcscfInfo::PcscfInfo()
{
    m_AccessTypeIsSet = false;
    m_DnnListIsSet = false;
    m_GmFqdn = "";
    m_GmFqdnIsSet = false;
    m_GmIpv4AddressesIsSet = false;
    m_GmIpv6AddressesIsSet = false;
    m_ServedIpv4AddressRangesIsSet = false;
    m_ServedIpv6PrefixRangesIsSet = false;
    
}

void PcscfInfo::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool PcscfInfo::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool PcscfInfo::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "PcscfInfo" : pathPrefix;

         
    if (accessTypeIsSet())
    {
        const std::vector<AccessType>& value = m_AccessType;
        const std::string currentValuePath = _pathPrefix + ".accessType";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const AccessType& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath) && success;
        
        
 
                i++;
            }
        }

    }
         
    if (dnnListIsSet())
    {
        const std::vector<std::string>& value = m_DnnList;
        const std::string currentValuePath = _pathPrefix + ".dnnList";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
             
    if (gmIpv4AddressesIsSet())
    {
        const std::vector<std::string>& value = m_GmIpv4Addresses;
        const std::string currentValuePath = _pathPrefix + ".gmIpv4Addresses";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
         
    if (gmIpv6AddressesIsSet())
    {
        const std::vector<Ipv6Addr>& value = m_GmIpv6Addresses;
        const std::string currentValuePath = _pathPrefix + ".gmIpv6Addresses";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const Ipv6Addr& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".gmIpv6Addresses") && success;
 
                i++;
            }
        }

    }
         
    if (servedIpv4AddressRangesIsSet())
    {
        const std::vector<Ipv4AddressRange>& value = m_ServedIpv4AddressRanges;
        const std::string currentValuePath = _pathPrefix + ".servedIpv4AddressRanges";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const Ipv4AddressRange& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".servedIpv4AddressRanges") && success;
 
                i++;
            }
        }

    }
         
    if (servedIpv6PrefixRangesIsSet())
    {
        const std::vector<Ipv6PrefixRange>& value = m_ServedIpv6PrefixRanges;
        const std::string currentValuePath = _pathPrefix + ".servedIpv6PrefixRanges";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const Ipv6PrefixRange& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".servedIpv6PrefixRanges") && success;
 
                i++;
            }
        }

    }
    
    return success;
}

bool PcscfInfo::operator==(const PcscfInfo& rhs) const
{
    return
    
    
    
    ((!accessTypeIsSet() && !rhs.accessTypeIsSet()) || (accessTypeIsSet() && rhs.accessTypeIsSet() && getAccessType() == rhs.getAccessType())) &&
    
    
    ((!dnnListIsSet() && !rhs.dnnListIsSet()) || (dnnListIsSet() && rhs.dnnListIsSet() && getDnnList() == rhs.getDnnList())) &&
    
    
    ((!gmFqdnIsSet() && !rhs.gmFqdnIsSet()) || (gmFqdnIsSet() && rhs.gmFqdnIsSet() && getGmFqdn() == rhs.getGmFqdn())) &&
    
    
    ((!gmIpv4AddressesIsSet() && !rhs.gmIpv4AddressesIsSet()) || (gmIpv4AddressesIsSet() && rhs.gmIpv4AddressesIsSet() && getGmIpv4Addresses() == rhs.getGmIpv4Addresses())) &&
    
    
    ((!gmIpv6AddressesIsSet() && !rhs.gmIpv6AddressesIsSet()) || (gmIpv6AddressesIsSet() && rhs.gmIpv6AddressesIsSet() && getGmIpv6Addresses() == rhs.getGmIpv6Addresses())) &&
    
    
    ((!servedIpv4AddressRangesIsSet() && !rhs.servedIpv4AddressRangesIsSet()) || (servedIpv4AddressRangesIsSet() && rhs.servedIpv4AddressRangesIsSet() && getServedIpv4AddressRanges() == rhs.getServedIpv4AddressRanges())) &&
    
    
    ((!servedIpv6PrefixRangesIsSet() && !rhs.servedIpv6PrefixRangesIsSet()) || (servedIpv6PrefixRangesIsSet() && rhs.servedIpv6PrefixRangesIsSet() && getServedIpv6PrefixRanges() == rhs.getServedIpv6PrefixRanges()))
    
    ;
}

bool PcscfInfo::operator!=(const PcscfInfo& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const PcscfInfo& o)
{
    j = nlohmann::json();
    if(o.accessTypeIsSet() || !o.m_AccessType.empty())
        j["accessType"] = o.m_AccessType;
    if(o.dnnListIsSet() || !o.m_DnnList.empty())
        j["dnnList"] = o.m_DnnList;
    if(o.gmFqdnIsSet())
        j["gmFqdn"] = o.m_GmFqdn;
    if(o.gmIpv4AddressesIsSet() || !o.m_GmIpv4Addresses.empty())
        j["gmIpv4Addresses"] = o.m_GmIpv4Addresses;
    if(o.gmIpv6AddressesIsSet() || !o.m_GmIpv6Addresses.empty())
        j["gmIpv6Addresses"] = o.m_GmIpv6Addresses;
    if(o.servedIpv4AddressRangesIsSet() || !o.m_ServedIpv4AddressRanges.empty())
        j["servedIpv4AddressRanges"] = o.m_ServedIpv4AddressRanges;
    if(o.servedIpv6PrefixRangesIsSet() || !o.m_ServedIpv6PrefixRanges.empty())
        j["servedIpv6PrefixRanges"] = o.m_ServedIpv6PrefixRanges;
    
}

void from_json(const nlohmann::json& j, PcscfInfo& o)
{
    if(j.find("accessType") != j.end())
    {
        j.at("accessType").get_to(o.m_AccessType);
        o.m_AccessTypeIsSet = true;
    } 
    if(j.find("dnnList") != j.end())
    {
        j.at("dnnList").get_to(o.m_DnnList);
        o.m_DnnListIsSet = true;
    } 
    if(j.find("gmFqdn") != j.end())
    {
        j.at("gmFqdn").get_to(o.m_GmFqdn);
        o.m_GmFqdnIsSet = true;
    } 
    if(j.find("gmIpv4Addresses") != j.end())
    {
        j.at("gmIpv4Addresses").get_to(o.m_GmIpv4Addresses);
        o.m_GmIpv4AddressesIsSet = true;
    } 
    if(j.find("gmIpv6Addresses") != j.end())
    {
        j.at("gmIpv6Addresses").get_to(o.m_GmIpv6Addresses);
        o.m_GmIpv6AddressesIsSet = true;
    } 
    if(j.find("servedIpv4AddressRanges") != j.end())
    {
        j.at("servedIpv4AddressRanges").get_to(o.m_ServedIpv4AddressRanges);
        o.m_ServedIpv4AddressRangesIsSet = true;
    } 
    if(j.find("servedIpv6PrefixRanges") != j.end())
    {
        j.at("servedIpv6PrefixRanges").get_to(o.m_ServedIpv6PrefixRanges);
        o.m_ServedIpv6PrefixRangesIsSet = true;
    } 
    
}

std::vector<AccessType> PcscfInfo::getAccessType() const
{
    return m_AccessType;
}
void PcscfInfo::setAccessType(std::vector<AccessType> const& value)
{
    m_AccessType = value;
    m_AccessTypeIsSet = true;
}
bool PcscfInfo::accessTypeIsSet() const
{
    return m_AccessTypeIsSet;
}
void PcscfInfo::unsetAccessType()
{
    m_AccessTypeIsSet = false;
}
std::vector<std::string> PcscfInfo::getDnnList() const
{
    return m_DnnList;
}
void PcscfInfo::setDnnList(std::vector<std::string> const& value)
{
    m_DnnList = value;
    m_DnnListIsSet = true;
}
bool PcscfInfo::dnnListIsSet() const
{
    return m_DnnListIsSet;
}
void PcscfInfo::unsetDnnList()
{
    m_DnnListIsSet = false;
}
std::string PcscfInfo::getGmFqdn() const
{
    return m_GmFqdn;
}
void PcscfInfo::setGmFqdn(std::string const& value)
{
    m_GmFqdn = value;
    m_GmFqdnIsSet = true;
}
bool PcscfInfo::gmFqdnIsSet() const
{
    return m_GmFqdnIsSet;
}
void PcscfInfo::unsetGmFqdn()
{
    m_GmFqdnIsSet = false;
}
std::vector<std::string> PcscfInfo::getGmIpv4Addresses() const
{
    return m_GmIpv4Addresses;
}
void PcscfInfo::setGmIpv4Addresses(std::vector<std::string> const& value)
{
    m_GmIpv4Addresses = value;
    m_GmIpv4AddressesIsSet = true;
}
bool PcscfInfo::gmIpv4AddressesIsSet() const
{
    return m_GmIpv4AddressesIsSet;
}
void PcscfInfo::unsetGmIpv4Addresses()
{
    m_GmIpv4AddressesIsSet = false;
}
std::vector<Ipv6Addr> PcscfInfo::getGmIpv6Addresses() const
{
    return m_GmIpv6Addresses;
}
void PcscfInfo::setGmIpv6Addresses(std::vector<Ipv6Addr> const& value)
{
    m_GmIpv6Addresses = value;
    m_GmIpv6AddressesIsSet = true;
}
bool PcscfInfo::gmIpv6AddressesIsSet() const
{
    return m_GmIpv6AddressesIsSet;
}
void PcscfInfo::unsetGmIpv6Addresses()
{
    m_GmIpv6AddressesIsSet = false;
}
std::vector<Ipv4AddressRange> PcscfInfo::getServedIpv4AddressRanges() const
{
    return m_ServedIpv4AddressRanges;
}
void PcscfInfo::setServedIpv4AddressRanges(std::vector<Ipv4AddressRange> const& value)
{
    m_ServedIpv4AddressRanges = value;
    m_ServedIpv4AddressRangesIsSet = true;
}
bool PcscfInfo::servedIpv4AddressRangesIsSet() const
{
    return m_ServedIpv4AddressRangesIsSet;
}
void PcscfInfo::unsetServedIpv4AddressRanges()
{
    m_ServedIpv4AddressRangesIsSet = false;
}
std::vector<Ipv6PrefixRange> PcscfInfo::getServedIpv6PrefixRanges() const
{
    return m_ServedIpv6PrefixRanges;
}
void PcscfInfo::setServedIpv6PrefixRanges(std::vector<Ipv6PrefixRange> const& value)
{
    m_ServedIpv6PrefixRanges = value;
    m_ServedIpv6PrefixRangesIsSet = true;
}
bool PcscfInfo::servedIpv6PrefixRangesIsSet() const
{
    return m_ServedIpv6PrefixRangesIsSet;
}
void PcscfInfo::unsetServedIpv6PrefixRanges()
{
    m_ServedIpv6PrefixRangesIsSet = false;
}


} // namespace org::openapitools::server::model

